/* 递归 */
// 递归：如果函数调用它本身，那么此函数就是递归的recursive, 例如公式n!=nx(n-1)!
// 在树的前/中/后序遍历中，递归的实现明显比循环简单。
//
// 优点：
// 1.代码简洁;
// 2.易于理解
// 缺点：
// 1.时间和空间的消耗比较大：递归由于是函数调用自身，而函数的调用时消耗时间和空间的，每一次函数调用，都需要在内存栈中分配空间以保存参数，
//   返回值和临时变量，而往栈中压入和弹出数据也都需要时间，所以降低了效率。
// 2.重复计算：递归中又很多计算都是重复的，递归的本质是把一个问题分解成两个或多个小 问题，多个小问题存在重叠的部分，即存在重复计算，如斐波那契数列的递归实现。
// 3.调用栈溢出：递归可能时调用栈溢出，每次调用时都会在内存栈中分配空间，而栈空间的容量是有限的，当调用的次数太多，就可能会超出栈的容量，进而造成调用栈溢出。

// 递归经常作为分治法divide-and-conquer的结果自然地出现。分治法的算法设计方法把一个大问题划分为多个较小的问题，然后采用相同的算法分别解决这些小问题。
// 分治法的经典示例就是流行的排序算法————快速排序quicksort。

#include <stdio.h>

// 函数声明
int fact(int n);

int main(void)
{
   int x = fact(5);
   printf("fact 5 =%d\n", x);
}

int fact(int n)
{
    if (n < 1)
    {
        return 1;
    }
    return n * fact(n - 1);
}
