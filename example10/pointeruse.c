/* 指针基础 */
// 指针变量的声明：int *poiner; 格式是: 存储的地址是哪种类型数据的地址，此处的int就表示该指针变量存储的地址是int类型数据的地址
//
// 数组的特别之处：对于int a[10]数组而言，因为数组在内存时连续分配地址的，因此实际上只需要知道数组的第一个元素的地址，就可以知道所有数组元素的地址。
// 因此对数组定义指针指向它时，无需为每个数组元素地址分配一个指针变量去存储，只需要为第一个数组元素地址分配一个指针变量即可。例如:int *p = a; 或 int *p = &a[0]; 
// 就是将数组的首地址存储到指针变量p，或者说p指向数组a的首地址。PS：C语言中，数组名就可以直接表示数组的首地址，因此int *p = a 等价于 int *p = &a[0];
//
// 注意：int *p[10]; 定义的并不是一个指向数组的指针。而是一个指针数组。首先：它是一个数组；其次数字中每个元素都是一个指针变量。也就是这个数组中10个元素都是指针/地址。
// 所以数组指针起始就是数组名、或数组首地址；而指针数组表示的是数组中所有的元素都是指针类型。

#include <stdio.h>

/* prototypes */
int sum(int *a, int *b, int length);

int main(void)
{
   int a = 20;
   int b[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

   sum(&a, b, 10);
   // a的值被改变了，因为指针操作改变的是内存地址对应的存储值，而不是拷贝
   printf("a = %d", a);
   return 0;
}

/*******************************************************
 * sum: 对一个整型与一个整型数组进行求和
 * x: int指针变量: int变量的内存地址
 * y: int数组指针变量: int数组变量的内存起始地址
 * length: 数组的长度: C语言不知道数组的长度，需要你告诉它
 * return: 返回值是求和的总值
 *
 * ******************************************************/
int sum(int *x, int *y, int length)
{
    // 在变量声明语句中：int *p1中*是用于声明该变量是指针类型的变量, 仅仅在声明时存在。
    // 指针就是地址；而指针变量是存储该地址的变量类型。
    int *p1 = x;
    // 此指针用于指向数组对象（实际就是数组的首地址，因为数组在内存中是连续分配的）
    int *p2 = y;

    // *是间接寻址运算符，*p1表示从p1这个指针变量所指向的地址中将存储的值取出来。
    int a = *p1;

    int sum = a;
    for(int i = 0; i < length; i++)
    {
	// 指针可以直接通过下标访问数组元素
	sum += p2[i];	
	// 也可以通过p2+i取得数组中第i个元素的地址，然后通过间接寻址运算符*取得该地址的元素值
	// 通过地址+1的方式可以寻址到数组的下一个元素的地址，因为数组是连续分配内存的。
	// 数组下标访问的本质就是这个原理：一个a[10]数组，数组名a就是地址/指针;a[2]其实就是等价于*(a+2)，它是代表第三个元素的地址对应存储的元素值。
	sum += *(p2+i);
	// 证明:数组名就是数组的首元素指针/地址
	sum += *(y+i);
    }

    // 改变指针指向的对象(对象不是java中的改变，而是抽象的改变), 实际地址对应的值也会被改变。
    *p1 += 90;
    printf("new x:%d", *p1);

    printf("sum is:%d\n", sum);

    return sum;
}


